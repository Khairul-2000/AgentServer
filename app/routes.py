from fastapi import APIRouter, HTTPException
from typing import List
import logging
import traceback
from .services import ProjectService, ProjectInput, projects_store
from .schemas import ProjectResponse, ProjectListResponse
from .graph import app_workflow

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

router = APIRouter()

@router.get("/")
async def root():
    return {"message": "Project Management System API with In-Memory Storage", "status": "healthy"}

@router.post("/generate-project-plan", response_model=ProjectResponse)
async def generate_project_plan(project_input: ProjectInput):
    try:
        logger.info(f"Generating project plan for: {project_input.project_type}")
        
        # Validate input
        if not project_input.project_type.strip():
            raise HTTPException(status_code=400, detail="Project type is required")
        if not project_input.objectives.strip():
            raise HTTPException(status_code=400, detail="Project objectives are required")
        if not project_input.industry.strip():
            raise HTTPException(status_code=400, detail="Industry is required")
        
        # Create project in memory using service
        project = ProjectService.create_project(project_input)
        logger.info(f"Created project with ID: {project.id}")

        # Format the input for the LangGraph workflow
        formatted_input = f"""
**Project Type:** {project_input.project_type}

**Project Objectives:** {project_input.objectives}

**Industry:** {project_input.industry}

**Team Members:**
{chr(10).join([f"- {member}" for member in project_input.team_members if member.strip()])}

**Project Requirements:**
{chr(10).join([f"- {req}" for req in project_input.requirements if req.strip()])}
"""

        # Initialize the workflow state properly
        initial_state = {
            "input": formatted_input,
            "plan": "",
            "schedule": "",
            "review": "",
            "html_output": ""
        }

        # Run the workflow
        logger.info("Running AI workflow...")
        logger.info(f"Input data length: {len(formatted_input)} characters")
        
        try:
            output = app_workflow.invoke(initial_state)
            logger.info("AI workflow completed successfully")
            
            # Log the output to check what we received
            logger.info(f"Workflow output keys: {list(output.keys())}")
            logger.info(f"Plan length: {len(output.get('plan', ''))} characters")
            logger.info(f"Schedule length: {len(output.get('schedule', ''))} characters")
            logger.info(f"Review length: {len(output.get('review', ''))} characters")
            logger.info(f"HTML length: {len(output.get('html_output', ''))} characters")
            
            # Validate that we have all required outputs
            if not output.get("plan"):
                raise ValueError("No plan generated by workflow")
            if not output.get("schedule"):
                raise ValueError("No schedule generated by workflow")
            if not output.get("review"):
                raise ValueError("No review generated by workflow")
            if not output.get("html_output"):
                raise ValueError("No HTML output generated by workflow")
                
        except Exception as workflow_error:
            logger.error(f"Workflow execution failed: {str(workflow_error)}")
            logger.error(f"Workflow traceback: {traceback.format_exc()}")
            raise HTTPException(status_code=500, detail=f"AI workflow failed: {str(workflow_error)}")

        # Update project with generated content using service
        updated_project = ProjectService.update_project_results(
            project.id,
            output["plan"],
            output["schedule"],
            output["review"],
            output["html_output"]
        )

        if not updated_project:
            raise HTTPException(status_code=500, detail="Failed to update project with results")

        return ProjectResponse(
            id=updated_project.id,
            plan=output["plan"],
            schedule=output["schedule"],
            review=output["review"],
            html_output=output["html_output"],
            created_at=updated_project.created_at
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error generating project plan: {str(e)}")
        logger.error(f"Traceback: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

@router.get("/projects", response_model=List[ProjectListResponse])
async def get_projects():
    try:
        logger.info("Fetching all projects")
        projects = ProjectService.get_all_projects()
        logger.info(f"Found {len(projects)} projects")
        return [
            ProjectListResponse(
                id=project.id,
                project_type=project.project_type,
                objectives=project.objectives,
                industry=project.industry,
                created_at=project.created_at
            )
            for project in projects
        ]
    except Exception as e:
        logger.error(f"Error fetching projects: {str(e)}")
        logger.error(f"Traceback: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

@router.get("/projects/{project_id}", response_model=ProjectResponse)
async def get_project(project_id: str):
    try:
        logger.info(f"Fetching project: {project_id}")
        
        if not project_id or not project_id.strip():
            raise HTTPException(status_code=400, detail="Project ID is required")
            
        project = ProjectService.get_project_by_id(project_id)
        if not project:
            raise HTTPException(status_code=404, detail="Project not found")

        return ProjectResponse(
            id=project.id,
            plan=project.plan or "",
            schedule=project.schedule or "",
            review=project.review or "",
            html_output=project.html_output or "",
            created_at=project.created_at
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error fetching project {project_id}: {str(e)}")
        logger.error(f"Traceback: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

@router.delete("/projects/{project_id}")
async def delete_project(project_id: str):
    try:
        logger.info(f"Deleting project: {project_id}")
        
        if not project_id or not project_id.strip():
            raise HTTPException(status_code=400, detail="Project ID is required")
            
        if not ProjectService.delete_project(project_id):
            raise HTTPException(status_code=404, detail="Project not found")

        logger.info(f"Successfully deleted project: {project_id}")
        return {"message": "Project deleted successfully"}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error deleting project {project_id}: {str(e)}")
        logger.error(f"Traceback: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

@router.get("/projects/search/{query}")
async def search_projects(query: str):
    try:
        logger.info(f"Searching projects with query: {query}")
        
        if not query or not query.strip():
            raise HTTPException(status_code=400, detail="Search query is required")
            
        projects = ProjectService.search_projects(query)
        logger.info(f"Found {len(projects)} matching projects")
        return [
            ProjectListResponse(
                id=project.id,
                project_type=project.project_type,
                objectives=project.objectives,
                industry=project.industry,
                created_at=project.created_at
            )
            for project in projects
        ]
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error searching projects: {str(e)}")
        logger.error(f"Traceback: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

@router.get("/health")
async def health_check():
    """Health check endpoint"""
    try:
        projects_count = len(projects_store)
        return {
            "status": "healthy", 
            "storage": "in-memory", 
            "projects_count": projects_count,
            "timestamp": projects_store.__class__.__name__ if projects_store else "initialized"
        }
    except Exception as e:
        logger.error(f"Health check failed: {str(e)}")
        return {"status": "unhealthy", "error": str(e)}

@router.get("/debug/workflow-test")
async def test_workflow():
    """Debug endpoint to test the AI workflow with sample data"""
    try:
        logger.info("Testing workflow with sample data")
        
        sample_input = """
**Project Type:** Web Application

**Project Objectives:** Create a modern e-commerce website with user authentication, product catalog, shopping cart, and payment processing.

**Industry:** E-commerce

**Team Members:**
- John Doe (Full-stack Developer)
- Jane Smith (UI/UX Designer)
- Bob Johnson (Project Manager)

**Project Requirements:**
- Responsive design for mobile and desktop
- User registration and authentication
- Product search and filtering
- Shopping cart functionality
- Payment gateway integration
- Admin panel for inventory management
"""
        
        initial_state = {
            "input": sample_input,
            "plan": "",
            "schedule": "",
            "review": "",
            "html_output": ""
        }
        
        logger.info("Invoking workflow with sample data...")
        output = app_workflow.invoke(initial_state)
        
        return {
            "status": "success",
            "workflow_output": {
                "plan_length": len(output.get("plan", "")),
                "schedule_length": len(output.get("schedule", "")),
                "review_length": len(output.get("review", "")),
                "html_length": len(output.get("html_output", "")),
                "has_plan": bool(output.get("plan")),
                "has_schedule": bool(output.get("schedule")),
                "has_review": bool(output.get("review")),
                "has_html": bool(output.get("html_output")),
            },
            "sample_outputs": {
                "plan_preview": output.get("plan", "")[:200] + "..." if output.get("plan") else "No plan generated",
                "schedule_preview": output.get("schedule", "")[:200] + "..." if output.get("schedule") else "No schedule generated",
                "review_preview": output.get("review", "")[:200] + "..." if output.get("review") else "No review generated",
            }
        }
        
    except Exception as e:
        logger.error(f"Workflow test failed: {str(e)}")
        logger.error(f"Traceback: {traceback.format_exc()}")
        return {
            "status": "error",
            "error": str(e),
            "traceback": traceback.format_exc()
        }